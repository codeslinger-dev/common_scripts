# ----------------------------------------------------------------------------
# -- BASH Functions (Common) -------------------------------------------------
#
# This file defines the Common functions to be used in a Bash session.
#
# This file is intended to be "sourced" by .bashrc (or equivalent):
#
#    if [ -f /<path>/.bash_functions_common ]; then
#     source /<path>/.bash_functions_common
#    fi
#
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
#  PUBLIC CONSTANTS:  ANSI Terminal color codes (8/16 colors)
# ----------------------------------------------------------------------------
export TC_BLK='\033[0;30m'
export TC_GRY='\033[0;37m'
export TC_DRK='\033[0;90m'
export TC_RED='\033[0;91m'
export TC_GRN='\033[0;92m'
export TC_YEL='\033[0;93m'
export TC_BLU='\033[0;94m'
export TC_MAG='\033[0;95m'
export TC_CYN='\033[0;96m'
export TC_WHT='\033[0;97m'
export TC_OFF='\033[0m'


# ----------------------------------------------------------------------------
#  FUNCTION NAME: confirm_choice
# ----------------------------------------------------------------------------
#  DESCRIPTION  : This is a general-purpose function to ask Yes/No questions
#                 in Bash, either with or without a default answer. It keeps
#                 repeating the question until it gets a valid answer.
#
#                 Example:  Default to 'Yes' if the user presses enter
#                           without giving an answer:
#
#                           if confirm_choice "Do you want to proceed?" Y; then
#                             echo "Yes"
#                           else
#                             echo "No"
#                           fi
# ----------------------------------------------------------------------------
#  PARAMETERS   : $1 = Text string to display as prompt
#                 $2 = Default answer (Y or N)  [optional]
# ----------------------------------------------------------------------------
function confirm_choice()
{
    # Don't pollute external environment
    local question=${1}
    local choice
    local default
    local reply

    # Requested "Y" as the default answer
    if [ "${2:-}" = "Y" ]; then
        choice="Y/n"
        default=Y

    # Requested "N" as the default answer
    elif [ "${2:-}" = "N" ]; then
        choice="y/N"
        default=N

    # No default answer requested
    else
        choice="y/n"
        default=
    fi

    # Continue until a recognized answer is provided
    while true; do

        # Display the prompt
        #  - intentially not using "read -p"
        #    as it uses stderr not stdout
        echo -e -n "$question [$choice]: "

        # Read the response
        #  - use /dev/tty in case stdin is
        #    redirected from somewhere else
        read reply </dev/tty

        # Use default?
        if [[ -z "$reply" ]] ; then
            reply=$default
        fi

        # Check if the reply is valid
        case "$reply" in
            Y*|y*) return 0 ;;
            N*|n*) return 1 ;;
        esac

    done

} # confirm_choice()


# ----------------------------------------------------------------------------
#  FUNCTION NAME: find_command_location
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Find the source location of a command
# ----------------------------------------------------------------------------
#  PARAMETERS   : $1 = Command to locate
# ----------------------------------------------------------------------------
function find_command_location()
{
    if [[ $# -eq 1 ]] ; then

      if [[ "$(type -t ${1})" == "function" ]] ; then
        shopt -s extdebug
        declare -F ${1}
      else
        type -a ${1}
      fi

    fi

} # find_command_location()


# ----------------------------------------------------------------------------
#  FUNCTION NAME: xterm_with_color
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Spawn an xterm with the provided color highlights
# ----------------------------------------------------------------------------
#  PARAMETERS   : $1 = Color to use for highlights (default: magenta)
# ----------------------------------------------------------------------------
function xterm_with_color()
{
    local hl_color=${1}

    if [[ -z ${hl_color} ]] ; then
      hl_color="magenta"
    fi

    xterm -ls                 \
          -sl 9182            \
          -bd ${hl_color}     \
          -ms ${hl_color}     \
          -cr ${hl_color}     \
          -rw                 \
          -title "[xterm]:" &

} # xterm_with_color()


# ----------------------------------------------------------------------------
#  FUNCTION NAME: xterm_set_title
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Dynamically set the title of the current xterm
# ----------------------------------------------------------------------------
#  PARAMETERS   : $1 = String to set as new title
# ----------------------------------------------------------------------------
function xterm_set_title()
{
    case "$TERM" in
    xterm*|rxvt*)
        echo -ne "\033]0;${1}\007"
        ;;
    *)
        ;;
    esac

} # xterm_set_title()


# ----------------------------------------------------------------------------
#  FUNCTION NAME: xterm_invoke_ssh
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Change the xterm title prior to invoking 'ssh'
# ----------------------------------------------------------------------------
#  PARAMETERS   : $@ = 'ssh' parameters
# ----------------------------------------------------------------------------
function xterm_invoke_ssh()
{
   local ssh_params="$@"

   xterm_set_title "Running: 'ssh ${ssh_params}'"
   \ssh ${ssh_params}

} # xterm_invoke_ssh()


# ----------------------------------------------------------------------------
#  FUNCTION NAME: xterm_invoke_su
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Change the xterm title prior to invoking 'su'
# ----------------------------------------------------------------------------
#  PARAMETERS   : $@ = 'su' parameters
# ----------------------------------------------------------------------------
function xterm_invoke_su()
{
   local su_params="$@"

   xterm_set_title "Running: 'su ${su_params}'"
   \su ${su_params}

} # xterm_invoke_su()


# ----------------------------------------------------------------------------
#  FUNCTION NAME: print_rainbow_line
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Prints a dashed line in alternating colors.  User provides
#                 the character and line length as the parameters.  The default
#                 length uses a single print, while custom values incur a
#                 performance penalty of a print per-character
#
#                 Unicode (UTF-8) characters are supported using
#                 hexidecimal notation (ex: '\xc2\xbb')
# ----------------------------------------------------------------------------
#  PARAMETERS   : $1 = Character   (default:  -)
#               : $2 = Line length (default: 60)
# ----------------------------------------------------------------------------
function print_rainbow_line()
{
  local color_array=($TC_RED $TC_YEL $TC_GRN $TC_BLU $TC_CYN $TC_MAG)
  local count_max=60
  local count=0
  local c='-'

  # Check for values provided
  if [ $# -lt 2 ]; then
     count_max=60
  else
     count_max=$2
  fi

  if [ $# -lt 1 ]; then
     c='-'
  else
     c=$1
  fi


  # Default value - single printf
  if [ $count_max -eq 60 ]; then

    local line="$TC_RED$c$TC_YEL$c$TC_GRN$c$TC_BLU$c$TC_CYN$c$TC_MAG$c"

    printf "%b%b%b%b%b%b%b%b%b%b${TC_OFF}\n"                   \
                      "$line" "$line" "$line" "$line" "$line"  \
                      "$line" "$line" "$line" "$line" "$line"

  # Otherwise, looping printf
  else

    # Print a character at a time, cycling colors
    for n in $(eval echo "{1..$count_max}") ; do

        local col=${color_array[$count]}

        printf "${col}%b" $c

        count=$(($count + 1))
        count=$(expr $count % 6)

    done

    # print newline
    printf "${TC_OFF}\n"

  fi

} # print_rainbow_line()


# ----------------------------------------------------------------------------
#  FUNCTION NAME: print_ansi_colors
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Prints (some) ANSI terminal color combinations
#
#                 Note:  Uses (mostly) the "vivid" color ranges
#                         - foreground = ( 90 - 97)
#                         - background = (100 -107)
# ----------------------------------------------------------------------------
#  PARAMETERS   : na
# ----------------------------------------------------------------------------
function print_ansi_colors()
{
    echo ""

    # Control Code Names
    #                    0       1      2     3        4         5      6       7        8
    local ctrl_names=("NORMAL" "BOLD" "DIM" "???" "UNDERLINE" "BLINK" "???" "REVERSE" "HIDDEN")

    # Test all control combinations
    for ctrl in 0 1 2 4 5 7 8; do
      echo " Control: ${ctrl_names[${ctrl}]} "

      # Each row - test all foreground (text-color) combinations
      for fg in {30..37} {90..97}; do
        echo -n "  "

        # First column - make no background changes
        echo -ne "\033[$ctrl;$fg""m\\\033[$ctrl;$fg""m\033[0m "

        # Remaining columns - test all background combinations
        for bg in {100..107}; do
          # Set the attributes, print the attribute ansi codes, reset
          echo -ne "\033[$ctrl;$fg;$bg""m\\\033[$ctrl;$fg;$bg""m\033[0m "
        done
        echo
      done
      echo ""
    done

    echo ""

} # print_ansi_colors()


# ----------------------------------------------------------------------------
#  FUNCTION NAME: log_get_current_timestamp
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Prints the current timestamp, for use with the logging
#                 function defined below
# ----------------------------------------------------------------------------
#  PARAMETERS   : na
# ----------------------------------------------------------------------------
function log_get_current_timestamp()
{
    local time_now=$(date +"%Y-%m-%d %H:%M:%S")
    echo "${time_now}"
}


# ----------------------------------------------------------------------------
#  FUNCTION NAME: log_error / log_warn / log_info / log_debug
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Prints the provided log message to stderr, pre-pending
#                 it with timestamp and color-coded [<LOG-TYPE>]
#
#                 Usage:  log_error "This is an error msg"
#                 Result: 2023-06-14 21:24:23 [ERROR] This is an error msg
# ----------------------------------------------------------------------------
#  PARAMETERS   : $1 = Message to print
# ----------------------------------------------------------------------------
function log_error()
{
    local time_now=$(log_get_current_timestamp)
    echo -e "${TC_DRK}${time_now}${TC_OFF} [${TC_RED}ERROR${TC_OFF}] ${1}" >&2
} # log_error()

function log_warn()
{
    local time_now=$(log_get_current_timestamp)
    echo -e "${TC_DRK}${time_now}${TC_OFF} [${TC_YEL} WARN${TC_OFF}] ${1}" >&2
} # log_warn()

function log_info()
{
    local time_now=$(log_get_current_timestamp)
    echo -e "${TC_DRK}${time_now}${TC_OFF} [${TC_MAG} INFO${TC_OFF}] ${1}" >&2
} # log_info()

function log_debug()
{
    local time_now=$(log_get_current_timestamp)
    echo -e "${TC_DRK}${time_now}${TC_OFF} [${TC_GRN}DEBUG${TC_OFF}] ${1}" >&2
} # log_debug()


# -- File has been sourced ---------------------------------------------------
FILE_SOURCED_FUNCTIONS_COMMON=TRUE

# -- End of File  ------------------------------------------------------------
# ----------------------------------------------------------------------------

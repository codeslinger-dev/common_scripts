# ----------------------------------------------------------------------------
# -- BASH Login Shell Greeting Display ---------------------------------------
#
# This file defines a custom greeting message for a Bash Shell interactive
# login.  It currently displays system stats and information to the user.
#
# This file is intended to be "sourced" by .bashrc:
#
#    if [ -f /<path>/.bash_greeting ]; then
#     source /<path>/.bash_greeting
#    fi
#
# ----------------------------------------------------------------------------


# -- Fetch this file's directory ---------------------------------------------
SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )


# -- Source Common Functions, if not present ---------------------------------
if [ -z $FILE_SOURCED_FUNCTIONS_COMMON ]; then
   if [ -f  ${SCRIPT_DIR}/.bash_functions_common ]; then
     source ${SCRIPT_DIR}/.bash_functions_common
   fi
fi


# ----------------------------------------------------------------------------
#  FUNCTION NAME: display_system_uptime
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Display the formatted system uptime
#                  ex:  1 week, 3 days, 21 hours, 45 minutes
# ----------------------------------------------------------------------------
#  PARAMETERS   : na
# ----------------------------------------------------------------------------
function display_system_uptime()
{
  # Check if the version of 'uptime' supports the "pretty format" option (-p)
  uptime -p >/dev/null 2>&1

  if [ "$?" -eq 0 ]; then

    # Pretty-format:  Supported

    # Note:  When the system is up for less than '0' minutes, then
    #       'uptime -p' returns ONLY 'up', so set a default value

    UPTIME_SET_OR_EMPTY=$(uptime -p | awk -F 'up ' '{print $2}')
    UPTIME=${UPTIME_SET_OR_EMPTY:-'less than a minute'}
  else

    # Pretty-format:  Unsupported

    # Parse the results and format to:  days, hours, minutes

    UPTIME=$(uptime | sed -E 's/^[^,]*up *//; s/mins/minutes/; s/hrs?/hours/;
    s/([[:digit:]]+):0?([[:digit:]]+)/\1 hours, \2 minutes/;
    s/^1 hours/1 hour/; s/ 1 hours/ 1 hour/;
    s/min,/minutes,/; s/ 0 minutes,/ less than a minute,/; s/ 1 minutes/ 1 minute/;
    s/  / /; s/, *[[:digit:]]* users?.*//')
  fi

  echo ${UPTIME}

} # display_system_uptime()


# ----------------------------------------------------------------------------
#  FUNCTION NAME: display_processor_name
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Display the formatted processor name
# ----------------------------------------------------------------------------
#  PARAMETERS   : na
# ----------------------------------------------------------------------------
function display_processor_name()
{
  # Attempt #1:  Parse /proc/cpuinfo
  if [[ -f /proc/cpuinfo ]]; then
    CPU_NAME=$(awk -F':' '/model name/{ print $2 }' /proc/cpuinfo | head -n 1 | tr -s " " | sed 's/^ //')
  fi

  # Attempt #2:  Parse /proc/cpuinfo (alternate format)
  if [[ -z "$CPU_NAME" ]]; then
    if [[ -f /proc/cpuinfo ]]; then
      CPU_NAME=$(awk -F':' '/Model/{ print $2 }' /proc/cpuinfo | head -n 1 | tr -s " " | sed 's/^ //')
    fi
  fi

  # Attempt #3:  Parse lscpu results
  if [[ -z "$CPU_NAME" ]]; then
    # Check if available
    lscpu >/dev/null 2>&1

    if [ "$?" -eq 0 ]; then
      CPU_NAME=$(lscpu | grep 'Model name' | cut -f 2 -d ":" | awk '{$1=$1}1')
    fi
  fi

  # Attempt #4:  Parse sysctl results (MacOS)
  if [[ -z "$CPU_NAME" ]]; then
    # Check if available
    sysctl -n machdep.cpu.brand_string  >/dev/null 2>&1

    if [ "$?" -eq 0 ]; then
      CPU_NAME=$(sysctl -n machdep.cpu.brand_string)
    fi
  fi

  # Attempt #5:  Parse sysctl results (FreeBSD)
  if [[ -z "$CPU_NAME" ]]; then
    # Check if available
    sysctl -n hw.model  >/dev/null 2>&1

    if [ "$?" -eq 0 ]; then
      CPU_NAME=$(sysctl -n hw.model)
    fi
  fi


  # Out of options:  Default value
  if [[ -z "$CPU_NAME" ]]; then
    CPU_NAME="---"
  fi

  echo ${CPU_NAME}

} # display_processor_name()


# ----------------------------------------------------------------------------
#  FUNCTION NAME: display_num_cpu_cores
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Display the physical core-count of the CPU
#                  [Sockets] x [Cores-Per-Socket]
# ----------------------------------------------------------------------------
#  PARAMETERS   : na
# ----------------------------------------------------------------------------
function display_num_cpu_cores()
{
  local num_sockets=1
  local cores_per_socket=1

  # Check for 'lscpu' command
  lscpu >/dev/null 2>&1

  if [ "$?" -eq 0 ]; then
    num_sockets=$(lscpu | grep "Socket(s):" | awk '{ print $2 }' | head -1 | tail -1 | tr -d '\r ')
    cores_per_socket=$(lscpu | grep "Core(s) per socket" | awk '{ print $4 }' | head -1 | tail -1 | tr -d '\r ')

    NUM_CPU_CORES=$( echo "${num_sockets} * ${cores_per_socket}" | bc )
  fi

  # Attempt 2
  if [[ -z "$NUM_CPU_CORES" ]]; then
    # Check if available
    sysctl -n  hw.physicalcpu >/dev/null 2>&1

    if [ "$?" -eq 0 ]; then
      NUM_CPU_CORES=$(sysctl -n hw.physicalcpu)
    fi
  fi


  # Out of options:  Default value
  if [[ -z "$NUM_CPU_CORES" ]]; then
    NUM_CPU_CORES=1
  fi

  echo ${NUM_CPU_CORES}

} # display_num_cpu_cores()


# ----------------------------------------------------------------------------
#  FUNCTION NAME: display_num_cpu_hwthreads
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Display the number hardware threads for the CPU
#                  [Sockets] x [Cores-Per-Socket] x [Threads-Per-Core]
# ----------------------------------------------------------------------------
#  PARAMETERS   : na
# ----------------------------------------------------------------------------
function display_num_cpu_hwthreads()
{
  local num_cores=$(display_num_cpu_cores)
  local threads_per_core=1

  # Check for 'lscpu' command
  lscpu >/dev/null 2>&1

  if [ "$?" -eq 0 ]; then
    threads_per_core=$(lscpu | grep "Thread(s) per core:" | awk '{ print $4 }' | head -1 | tail -1 | tr -d '\r ')
  else
    threads_per_core=$( echo `getconf _NPROCESSORS_ONLN` / ${num_cores} | bc )
  fi

  # Set minimum to 1
  if [ ${threads_per_core} -lt 1 ]; then
    threads_per_core=1
  fi

  NUM_CPU_HWTHREADS=$( echo "${num_cores} * ${threads_per_core}" | bc )

  echo ${NUM_CPU_HWTHREADS}

} # display_num_cpu_hwthreads()


# ----------------------------------------------------------------------------
#  FUNCTION NAME: display_home_size_total
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Display the formatted total size of /home
# ----------------------------------------------------------------------------
#  PARAMETERS   : na
# ----------------------------------------------------------------------------
function display_home_size_total()
{
  # Attempt 1
  HOME_SIZE=`df -h ~ |  grep -v "Size" | awk '{ print $2 }' | head -1 | tail -1 | tr -d '\r '`

  # Attempt 2
  if [[ -z "$HOME_SIZE" ]]; then
    HOME_SIZE=`df -h |  grep "home" | awk '{ print $2 }' | head -1 | tail -1 | tr -d '\r '`
  fi

  # Out of options:  Default value
  if [[ -z "$HOME_SIZE" ]]; then
    HOME_SIZE="---"
  fi

  echo ${HOME_SIZE}

} # display_home_size_total()


# ----------------------------------------------------------------------------
#  FUNCTION NAME: display_home_size_free
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Display the formatted free size of /home
# ----------------------------------------------------------------------------
#  PARAMETERS   : na
# ----------------------------------------------------------------------------
function display_home_size_free()
{
  # Attempt 1
  HOME_FREE=`df -h ~ |  grep -v "Size" | awk '{ print $4 }' | head -1 | tail -1 | tr -d '\r '`

  # Attempt 2
  if [[ -z "$HOME_FREE" ]]; then
    HOME_FREE=`df -h |  grep "home" | awk '{ print $4 }' | head -1 | tail -1 | tr -d '\r '`
  fi

  # Out of options:  Default value
  if [[ -z "$HOME_FREE" ]]; then
    HOME_FREE="---"
  fi

  echo ${HOME_FREE}

} # display_home_size_free()


# ----------------------------------------------------------------------------
#  FUNCTION NAME: display_mem_total
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Display the total amount of system ram (in GB)
# ----------------------------------------------------------------------------
#  PARAMETERS   : na
# ----------------------------------------------------------------------------
function display_mem_total()
{
  # Attempt #1: Parse /proc/meminfo for memory (in kB)
  if [ -f "/proc/meminfo" ]; then
    MEM_SIZE=$( awk '/MemTotal/ { print $2 }' /proc/meminfo )
  else
    MEM_SIZE=""
  fi

  # Attempt #2:  Parse sysctl results for memory (in bytes) (macOS)
  if [[ -z "$MEM_SIZE" ]]; then
    # Check if available
    sysctl -n hw.memsize  >/dev/null 2>&1

    if [ "$?" -eq 0 ]; then
      MEM_SIZE=$(sysctl -n hw.memsize)
      MEM_SIZE=$( echo "${MEM_SIZE} / 1024" | bc )
    fi
  fi

  # Attempt #3:  Parse sysctl results for memory (in bytes) (FreeBSD)
  if [[ -z "$MEM_SIZE" ]]; then
    # Check if available
    sysctl -n hw.physmem  >/dev/null 2>&1

    if [ "$?" -eq 0 ]; then
      MEM_SIZE=$(sysctl -n hw.physmem)
      MEM_SIZE=$( echo "${MEM_SIZE} / 1024" | bc )
    fi
  fi


  # Convert kB into GB)
  if [[ -z "$MEM_SIZE" ]]; then
    MEM_SIZE="---"
  else
    MEM_SIZE=$( echo "scale=1 ; ${MEM_SIZE} / 1024 / 1024" | bc )
  fi

  echo ${MEM_SIZE}

} # display_mem_total()


# ----------------------------------------------------------------------------
#  FUNCTION NAME: display_mem_free
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Display the free amount of system ram (in GB)
# ----------------------------------------------------------------------------
#  PARAMETERS   : na
# ----------------------------------------------------------------------------
function display_mem_free()
{
  # Attempt #1: Parse /proc/meminfo for memory (in kB)
  if [ -f "/proc/meminfo" ]; then
    MEM_FREE=$( awk '/MemAvailable/ { print $2 }' /proc/meminfo )
  fi

  # Attempt #2: Parse /proc/meminfo for memory (in kB)
  if [[ -z "$MEM_FREE" ]]; then
    # Try memFree as an alternate
    if [ -f "/proc/meminfo" ]; then
      MEM_FREE=$( awk '/MemFree/ { print $2 }' /proc/meminfo )
    fi
  fi

  # Attempt #3: Parse sysctl results for memory (in bytes)  (FreeBSD)
  if [[ -z "$MEM_FREE" ]]; then
    # Check if available
    sysctl -n hw.pagesize  >/dev/null 2>&1

    if [ "$?" -eq 0 ]; then
      page_size=$(sysctl -n hw.pagesize)

      # Check if available
      sysctl -n vm.stats.vm.v_free_count  >/dev/null 2>&1

      if [ "$?" -eq 0 ]; then
        free_bytes_per_page=$(sysctl -n vm.stats.vm.v_free_count)
        MEM_FREE=$( echo "${page_size} * ${free_bytes_per_page} / 1024" | bc )
      fi
    fi
  fi


  # Convert kB into GB)
  if [[ -z "$MEM_FREE" ]]; then
    MEM_FREE="---"
  else
    MEM_FREE=$( echo "scale=1 ;${MEM_FREE} / 1024 / 1024" | bc )
  fi

  echo ${MEM_FREE}

} # display_mem_free()


# ----------------------------------------------------------------------------
#  FUNCTION NAME: display_greeting
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Display the system greeting
# ----------------------------------------------------------------------------
#  PARAMETERS   : na
# ----------------------------------------------------------------------------
function display_greeting()
{
  # Fetch system information
  local sys_user=$( echo "$USER" )
  local sys_host=$(hostname)
  local sys_kernel_name=$(uname -s)
  local sys_kernel_rel=$(uname -r)
  local sys_kernel_arch=$(uname -m)
  local sys_cpu=$(display_processor_name)
  local sys_cpu_cores=$(display_num_cpu_cores)
  local sys_cpu_threads=$(display_num_cpu_hwthreads)
  local sys_homedir_size=$(display_home_size_total)
  local sys_homedir_free=$(display_home_size_free)
  local sys_mem_size=$(display_mem_total)
  local sys_mem_free=$(display_mem_free)
  local sys_uptime=$(display_system_uptime)


  # Display Greeting
  echo ""
  echo -e "--------------------------------------------------------------------"
  echo -e " ${TC_CYN}Date${TC_OFF} :  `date '+%B %d, %Y (%A)'`"
  echo -e " ${TC_CYN}Time${TC_OFF} :  `date '+%r'`"
  echo -e " ${TC_CYN}Host${TC_OFF} :  ${TC_YEL}${sys_user}${TC_OFF} @ ${TC_YEL}${sys_host}${TC_OFF}"
  echo -e "  - ${TC_MAG}system${TC_OFF}    : ${sys_kernel_name} ${TC_MAG}|${TC_OFF} ${sys_kernel_rel} ${TC_MAG}|${TC_OFF} ${sys_kernel_arch}"
  echo -e "  - ${TC_MAG}processor${TC_OFF} : ${sys_cpu} ${TC_MAG}|${TC_OFF} ${sys_cpu_cores}C/${sys_cpu_threads}T"
  echo -e "  - ${TC_MAG}ram${TC_OFF}       : ${sys_mem_size} GB total ${TC_MAG}|${TC_OFF} ${sys_mem_free} GB free"
  echo -e "  - ${TC_MAG}/home${TC_OFF}     : ${sys_homedir_size} total ${TC_MAG}|${TC_OFF} ${sys_homedir_free} free"
  echo -e "  - ${TC_MAG}uptime${TC_OFF}    : ${sys_uptime}"
  echo -e "--------------------------------------------------------------------"
  echo ""

} # display_greeting()


# -- End of File  ------------------------------------------------------------
# ----------------------------------------------------------------------------

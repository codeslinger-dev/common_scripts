# ----------------------------------------------------------------------------
# -- BASH Login Shell Greeting Display ---------------------------------------
#
# This file defines a custom greeting message for a Bash Shell interactive
# login.  It currently displays system stats and information to the user.
#
# This file is intended to be "sourced" by .bashrc:
#
#    if [ -f /<path>/.bash_greeting ]; then
#     source /<path>/.bash_greeting
#    fi
#
# ----------------------------------------------------------------------------


# -- Fetch this file's directory ---------------------------------------------
SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )


# -- Source Common Functions, if not present ---------------------------------
if [ -z $FILE_SOURCED_FUNCTIONS_COMMON ]; then
   if [ -f  ${SCRIPT_DIR}/.bash_functions_common ]; then
     source ${SCRIPT_DIR}/.bash_functions_common
   fi
fi


# ----------------------------------------------------------------------------
#  FUNCTION NAME: display_system_uptime
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Display the formatted system uptime
#                  ex:  1 week, 3 days, 21 hours, 45 minutes
# ----------------------------------------------------------------------------
#  PARAMETERS   : na
# ----------------------------------------------------------------------------
function display_system_uptime()
{
  # Check if the version of 'uptime' supports the "pretty format" option (-p)
  uptime -p >/dev/null 2>&1

  if [ "$?" -eq 0 ]; then

    # Pretty-format:  Supported

    # Note:  When the system is up for less than '0' minutes, then
    #       'uptime -p' returns ONLY 'up', so set a default value

    UPTIME_SET_OR_EMPTY=$(uptime -p | awk -F 'up ' '{print $2}')
    UPTIME=${UPTIME_SET_OR_EMPTY:-'less than a minute'}
  else

    # Pretty-format:  Unsupported

    # Parse the results and format to:  weeks, days, hours, minutes

    UPTIME=$(uptime | sed -E 's/^[^,]*up *//; s/mins/minutes/; s/hrs?/hours/;
    s/([[:digit:]]+):0?([[:digit:]]+)/\1 hours, \2 minutes/;
    s/^1 hours/1 hour/; s/ 1 hours/ 1 hour/;
    s/min,/minutes,/; s/ 0 minutes,/ less than a minute,/; s/ 1 minutes/ 1 minute/;
    s/  / /; s/, *[[:digit:]]* users?.*//')
  fi

  echo ${UPTIME}

} # display_system_uptime()


# ----------------------------------------------------------------------------
#  FUNCTION NAME: display_processor_name
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Display the formatted processor name
# ----------------------------------------------------------------------------
#  PARAMETERS   : na
# ----------------------------------------------------------------------------
function display_processor_name()
{
  # Attempt #1:  Parse /proc/cpuinfo
  if [[ -f /proc/cpuinfo ]]; then
    CPU_NAME=$(awk -F':' '/model name/{ print $2 }' /proc/cpuinfo | head -n 1 | tr -s " " | sed 's/^ //')
  fi

  # Attempt #2:  Parse /proc/cpuinfo (alternate format)
  if [[ -z "$CPU_NAME" ]]; then
    if [[ -f /proc/cpuinfo ]]; then
      CPU_NAME=$(awk -F':' '/Model/{ print $2 }' /proc/cpuinfo | head -n 1 | tr -s " " | sed 's/^ //')
    fi
  fi

  # Attempt #3:  Parse lscpu results
  if [[ -z "$CPU_NAME" ]]; then
    # Check if available
    lscpu >/dev/null 2>&1

    if [ "$?" -eq 0 ]; then
      CPU_NAME=$(lscpu | grep 'Model name' | cut -f 2 -d ":" | awk '{$1=$1}1')
    fi
  fi

  # Attempt #4:  Parse sysctl results (MacOS)
  if [[ -z "$CPU_NAME" ]]; then
    # Check if available
    sysctl -n machdep.cpu.brand_string  >/dev/null 2>&1

    if [ "$?" -eq 0 ]; then
      CPU_NAME=$(sysctl -n machdep.cpu.brand_string)
    fi
  fi

  # Attempt #5:  Parse sysctl results (FreeBSD)
  if [[ -z "$CPU_NAME" ]]; then
    # Check if available
    sysctl -n hw.model  >/dev/null 2>&1

    if [ "$?" -eq 0 ]; then
      CPU_NAME=$(sysctl -n hw.model)
    fi
  fi


  # Out of options:  Default value
  if [[ -z "$CPU_NAME" ]]; then
    CPU_NAME="---"
  fi

  echo ${CPU_NAME}

} # display_processor_name()


# ----------------------------------------------------------------------------
#  FUNCTION NAME: display_home_size_total
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Display the formatted total size of /home
# ----------------------------------------------------------------------------
#  PARAMETERS   : na
# ----------------------------------------------------------------------------
function display_home_size_total()
{
  HOME_SIZE=`df -h ~ |  grep -v "Size" | awk '{ print $2 }' | head -1 | tail -1 | tr -d '\r '`

  if [[ -z "$HOME_SIZE" ]]; then
    HOME_SIZE=`df -h |  grep "home" | awk '{ print $2 }' | head -1 | tail -1 | tr -d '\r '`
  fi

  if [[ -z "$HOME_SIZE" ]]; then
    HOME_SIZE="---"
  fi

  echo ${HOME_SIZE}

} # display_home_size_total()


# ----------------------------------------------------------------------------
#  FUNCTION NAME: display_home_size_free
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Display the formatted free size of /home
# ----------------------------------------------------------------------------
#  PARAMETERS   : na
# ----------------------------------------------------------------------------
function display_home_size_free()
{
  HOME_FREE=`df -h ~ |  grep -v "Size" | awk '{ print $4 }' | head -1 | tail -1 | tr -d '\r '`

  if [[ -z "$HOME_FREE" ]]; then
    HOME_FREE=`df -h |  grep "home" | awk '{ print $4 }' | head -1 | tail -1 | tr -d '\r '`
  fi

  if [[ -z "$HOME_FREE" ]]; then
    HOME_FREE="---"
  fi

  echo ${HOME_FREE}

} # display_home_size_free()


# ----------------------------------------------------------------------------
#  FUNCTION NAME: display_mem_total
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Display the total amount of system ram (in GB)
# ----------------------------------------------------------------------------
#  PARAMETERS   : na
# ----------------------------------------------------------------------------
function display_mem_total()
{
  # Attempt #1: Parse /proc/meminfo for memory (in kB)
  if [ -f "/proc/meminfo" ]; then
    MEM_SIZE=$( awk '/MemTotal/ { print $2 }' /proc/meminfo )
  else
    MEM_SIZE=""
  fi

  # Attempt #2:  Parse sysctl results for memory (in bytes) (macOS)
  if [[ -z "$MEM_SIZE" ]]; then
    # Check if available
    sysctl -n hw.memsize  >/dev/null 2>&1

    if [ "$?" -eq 0 ]; then
      MEM_SIZE=$(sysctl -n hw.memsize)
      MEM_SIZE=$( echo "${MEM_SIZE} / 1024" | bc )
    fi
  fi

  # Attempt #3:  Parse sysctl results for memory (in bytes) (FreeBSD)
  if [[ -z "$MEM_SIZE" ]]; then
    # Check if available
    sysctl -n hw.physmem  >/dev/null 2>&1

    if [ "$?" -eq 0 ]; then
      MEM_SIZE=$(sysctl -n hw.physmem)
      MEM_SIZE=$( echo "${MEM_SIZE} / 1024" | bc )
    fi
  fi



  # Convert kB into GB)
  if [[ -z "$MEM_SIZE" ]]; then
    MEM_SIZE="---"
  else
    MEM_SIZE=$( echo "scale=1 ; ${MEM_SIZE} / 1024 / 1024" | bc )
  fi

  echo ${MEM_SIZE}

} # display_mem_total()


# ----------------------------------------------------------------------------
#  FUNCTION NAME: display_mem_free
# ----------------------------------------------------------------------------
#  DESCRIPTION  : Display the free amount of system ram (in GB)
# ----------------------------------------------------------------------------
#  PARAMETERS   : na
# ----------------------------------------------------------------------------
function display_mem_free()
{
  if [ -f "/proc/meminfo" ]; then
    MEM_FREE=$( awk '/MemAvailable/ { print $2 }' /proc/meminfo )
  else
    MEM_FREE=""
  fi

  if [[ -z "$MEM_FREE" ]]; then
    # Try memFree as an alternate
    if [[ -f /proc/meminfo ]]; then
      MEM_FREE=$( awk '/MemFree/ { print $2 }' /proc/meminfo )
    fi
  fi

  # Convert kB into GB)
  if [[ -z "$MEM_FREE" ]]; then
    MEM_FREE="---"
  else
    MEM_FREE=$( echo "scale=1 ;${MEM_FREE} / 1024 / 1024" | bc )
  fi

  echo ${MEM_FREE}

} # display_mem_free()



# -- Gather system information -----------------------------------------------

# Fetch user
sys_user=$( echo "$USER" )

# Fetch host
sys_host=$(hostname)

# Fetch kernel name
sys_kernel_name=$(uname -s)

# Fetch kernel release
sys_kernel_rel=$(uname -r)

# Fetch kernel architecture
sys_kernel_arch=$(uname -m)

# Fetch processor name
sys_cpu=$(display_processor_name)

# Fetch size of /home (or equivalent)
sys_homedir_size=$(display_home_size_total)

# Fetch free space of /home (or equivalent)
sys_homedir_free=$(display_home_size_free)

# Fetch available memory
sys_mem_size=$(display_mem_total)

# Fetch available memory
sys_mem_free=$(display_mem_free)

# Fetch system uptime
sys_uptime=$(display_system_uptime)


# -- Display Greeting --------------------------------------------------------

echo ""
echo -e "--------------------------------------------------------------------"
echo -e " ${TC_CYN}Date${TC_OFF} :  `date '+%B %d, %Y (%A)'`"
echo -e " ${TC_CYN}Time${TC_OFF} :  `date '+%r'`"
echo -e " ${TC_CYN}Host${TC_OFF} :  ${TC_YEL}${sys_user}${TC_OFF} @ ${TC_YEL}${sys_host}${TC_OFF}"
echo -e "  - ${TC_MAG}system${TC_OFF}    : ${sys_kernel_name} ${TC_MAG}|${TC_OFF} ${sys_kernel_rel} ${TC_MAG}|${TC_OFF} ${sys_kernel_arch}"
echo -e "  - ${TC_MAG}processor${TC_OFF} : ${sys_cpu}"
echo -e "  - ${TC_MAG}ram${TC_OFF}       : ${sys_mem_size} GB total (${sys_mem_free} GB free)"
echo -e "  - ${TC_MAG}/home${TC_OFF}     : ${sys_homedir_size} total (${sys_homedir_free} free)"
echo -e "  - ${TC_MAG}uptime${TC_OFF}    : ${sys_uptime}"
echo -e "--------------------------------------------------------------------"
echo ""


# -- End of File  ------------------------------------------------------------
# ----------------------------------------------------------------------------
